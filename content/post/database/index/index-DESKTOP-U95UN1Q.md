---
title: "第三章 索引"
description: 
date: 2023-10-07T23:40:16+08:00
image:
url: /db/index
math: false
comments: true
draft: false
categories:
---

# 哈希索引

## 可扩展哈希表

## 线性哈希表

# 平衡树索引

## B+树

B+树

一个B+树是一个M路平衡搜索树

B+树分为根节点,内节点以及叶子节点
其中只有叶子节点存储数据,内节点和根节点中的值仅仅用来导航

B+树和BST的有序是类似的,节点中key左侧子树都小于key,右侧子树都大于等于key

有以下特征
1. B+树是完全平衡的,叶子节点均在同一层,不会出现叶子节点高度差1的情况
2. 除了根节点以外,每个节点至少是半满的
即每个节点中的key的数量为$M/2 - 1 <#key < M-1$

说明:一个节点最多M路,也就是M个子树,因此key的数量最多M-1

3. B+树一种常见的外村数据结构,每个节点的大小和页(数据块)的大小相等

**B+树的叶节点**

每个叶节点包含一个索引项数组和一个指向右侧兄弟叶节点的指针(右侧兄弟节点的页号)
- 索引项数组通常按索引键排序

B+树的叶子节点是有序的,并且会通过sibling pointer前后相连,因此找前驱和后继很方面,时间复杂度是$O(1)$,虽然使用sibling pointer描述,不过在实现上,这个next指针和previous指针保存的内容是pageId,而不是内存指针(因此在B+树这一章节,看到的指针的字样,都可以用pageId来替换,只不过指针比较好理解)

![](2023-10-08-17-31-45.png)

**B+树的内节点**

每个内节点包含一个键数组Key和一个指向儿子节点的指针数组Ptr
- Key中有k个键时,Ptr中有k+1个指针
- Key中的键值有序
- Ptr[0] 指向的子树中的键值 < Key[0]
- Ptr[k+1]指向的子树的键值 >= Key[k]
- Ptr[k]指向的子树的键值 < Key[k]
- Key[i-1]<= Ptr[i]指向的子树中的键值 < Key[i]
  
![](2023-10-08-17-23-40.png)

**B+树的根节点**

根节点和内节点的内部结构相同,但是不要求"半满"

**B+树的查找**

B+树的查找很简单,采用和BST类型的查找方式即可

**B+树的区间查找**

B+树的区间查找也很简单,先找到开始位置,但是沿着叶子节点上的指针挨个遍历,直到找到终点即可

**B+树的插入**
1. 找到$K$应在的叶节点$L$
2. 将索引项插入$L$
3. 如果$L$不溢出,则插入完成,否则分裂$L$

分裂叶节点$L$
1. 创建一个新的叶节点$L_2$
2. 将$L$中的索引项平分,前一半留在$L$中,后一半移入$L_2$中
3. 将$L_2$中最小的键(即最左侧的键)存入"中间键(middle key)"变量中(增加了一颗子树,因此相应的父节点需要增加一个指向这个子树的指针,因此父节点需要增加一个key)
4. 在叶节点链表中,将$L_2$插入到$L$的右侧
5. 在L的父节点$N$中插入middle key以及指向$L_2$的指针
6. 如果N不溢出,则完成分裂,否则,继续分裂N,直到根节点发生分裂,B+树的高度增加1,这个操作一定是可以终止的

在向父节点加key的时候,假设我们确定了new_key加在k1和k2之间,那么说明k1和k2之间的key发生了分裂Ptr[k1+1]和Ptr[k2+1]之间多了一个叶节点
如果说k2不存在,那么就是插入在最右侧的情况

在父节点也发生分裂的情况下,将父节点(M个节点)均分,但是实际上分裂的两个节点使用M-1个节点就可以保证所有指针均有所指,因此会多出来一个节点(我们选择多出来本来分给右侧节点中的第一个key作为多余),这个key作为middle key,继续向父节点插入

原本溢出的情况:M个节点,M+1个P
分裂后:
左侧节点: M/2个节点,M/2+1个P,这里M/2表示取下整
右侧节点：M-M/2, M-M/2+1个P
加一下我们就发现了多了一个P,因此可以将右侧节点少拿一个
实际的右侧节点：M-M/2-1个节点,M-M/2个P

![叶子节点分裂](image.png)

![父节点分裂](2023-10-08-18-39-33.png)

**B+树的删除**
1. 找到K所在的叶节点L
2. 从L中删除键为K的索引项
3. 如果L在删除之后仍然半满,则完成删除,否则处理L,使得L至少半满

使叶节点L至少半满的处理方法
1. 尝试从L的兄弟节点(有相同的父节点)借一个索引项,使两者均至少半满
2. 如果借不到,则将L与其兄弟节点合并

- 如果L与左侧兄弟节点$L_1$合并,则从L的父节点中删除指向L的指针以及相应的键
- 如果L与右侧兄弟节点$L_2$合并,则从$L_2$的父节点中删除指向$L_2$的指针以及相应的键
- 如果L的父节点在合并之后(删除了一个指针和一个键)至少半满,则完成合并,否则处理N,使得N至少半满
  - 如果N是根节点,且N中只有一个指针,则删除N,并将其唯一的子节点作为新的根节点
  - 如果N是内节点,则处理N(借或者合并),使得N至少半满
