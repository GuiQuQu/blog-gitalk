---
title: "go GC 垃圾回收机制"
description: 
date: 2023-09-05T15:55:29+08:00
image:
url: /go/gc
math: false
comments: false
draft: false
categories:
  - go
---

[reference1](https://learnku.com/articles/68141)

# GC

垃圾回收 (Garbage Collection，简称 GC) 是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。

# 标记清除算法

go v1.3之前——标记清除(mark-sweep)算法,主要存在两个步骤
1. 标记
2. 清除
3. 
(1) 暂停程序业务逻辑，分类标记出可达对象和不可达对象，然后做上标记

可达不可达的意思就是图的连通

(2) 开始标记，程序找出它所有的可达对象，并做上标记

(3) 标记完成之后，开始清除未标记的对象，释放内存空间

该算法需要注意的是在于执行时，需要程序暂停，等待垃圾回收完成，这个过程称为 STW (Stop The World)。

(4) 停止暂停，让程序继续跑

**标记-清除算法的缺点**
1. STW，程序暂停，程序出现卡顿(重要)
2. 标记需要扫描整个heap
3. 清除数据会产生heap碎片

# Go v1.5 三色并发标记法

Step1. 每次创建对象时，默认的颜色都标记为“白色”，放入“白色”集合

Step2. 每次GC回收开始时，会从根节点开始层序遍历一层对象，放入“灰色”集合

遍历的方式是层序遍历，而且只前进一层。

Step3. 层序遍历一层灰色集合，将遍历到的对象放入“灰色”集合，并将原来“灰色”集合中的对象放入“黑色”集合

Step4. 重复第三步，直到“灰色”集合中没有对象

这个过程结束之后，黑色集合中的点为可达对象，剩余在白色集合中的点是需要回收的垃圾

Step5. 回收所有白色集合中的对象

这个就是三色标记法的主要流程，但是这种方式仍旧需要STW，来防止程序修改对象的引用逻辑

# 没有STW的三色标记法

在三色标记法中，当下面两种情况同时发生时，GC将会误杀对象

1. 黑色新增一条到白色的边
   试想当黑色新增一条到灰色不可达的白色时，可想而知，这个白色会被误杀   
2. 灰色到白色的边丢失
   条件是说从原来的灰色可达变成了灰色不可达

因此这两个条件合起来就是**黑色新增一条到白色的边，且该白色不是灰色可达的点**

因此想要从STW解放出来，就是要破坏这两个条件

# 屏障机制

## "强-弱"三色不变式

- 强三色不变式：不存在黑色对象到白色对象的引用
  
  强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。

- 弱三色不变式
  所有黑色对象引用的白色对象都是灰色可达的(一步或者多步)

gc使用两种屏障方式来实现，分别是插入屏障和删除屏障

## 插入屏障

在A对象引用B对象时(新增A->B的边时)，B对象被标记为灰色

这种方式保证了强三色不变式，因为白色会被强制变成灰色
  
插入屏障主要在堆中使用

栈空间的特点是容量小，但是要求相应速度快，因为函数调用弹出频繁使用，所以 “插入屏障” 机制，在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.

因此在栈空间中还需要额外的STW来保证栈空间的正确性

## 删除屏障

操作：当A->B的边丢失时(即B被删除时)，如果B时灰色或者白色，将B标记为灰色

满足弱三色不变式

这种方式精度比较低，有时一些已经没有引用的对象还是可以活过这一轮GC，下次才会被回收

# Go v1.8 混合写屏障机制

Go V1.8 版本引入了混合写屏障机制（hybrid write barrier），避免了对栈 re-scan 的过程，极大的减少了 STW 的时间。结合了两者的优点。

操作
1. GC开始将栈上的对象扫描，将全部可达对象标记为黑色
2. GC期间，任何在栈上创建的新对象，均标记为黑色
3. 堆上删除引用关系A->B时，将B标记为灰色
4. 堆上引用关系A->B时，将B标记为灰色

3，4只在堆上执行，栈到堆，栈到栈，堆到栈均不触发

注意
新增边的时候，我们只能新增一个到原来可达的点的边，或者是一个新建节点，因为按照程序逻辑如果一个点已经成为了一个孤岛，那么说明程序已经抛弃了这个变量名，我们也就没法使用了




